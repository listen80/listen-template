(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.lt = factory());
})(this, (function () { 'use strict';

  // const DEVELOPMENT = 

  function toString$1(value) {
    if (value == undefined) {
      value = "";
    } else {
      value += "";
    }
    return value;
  }

  const map = {
    "<": "&#60;",
    ">": "&#62;",
    '"': "&#34;",
    "'": "&#39;",
    "&": "&#38;",
  };
  function escape$1(value) {
    return toString$1(value).replace(/&(?![\w#]+;)|[<>"']/g, function (s) {
      return map[s];
    });
  }

  function ArrayLike(obj) {
    return obj && typeof obj.length === "number";
  }

  function forEach$1(data, callback) {
    var i,
      len,
      count = 0;
    if (ArrayLike(data)) {
      for (i = 0, len = data.length; i < len; i++) {
        callback.call(data, data[i], i, i);
      }
    } else {
      for (i in data) {
        if (data.hasOwnProperty(i)) {
          callback.call(data, data[i], i, count);
          count++;
        }
      }
    }
  }

  var utils = {
    toString: toString$1,
    forEach: forEach$1,
    escape: escape$1,
  };

  function echo(code) {
    return "$o+=" + code + ";";
  }

  function for_html(code) {
    if (code) {
      return echo(
        "'" +
          code
            .replace(/('|\\)/g, "\\$1")
            .replace(/\r/g, "\\r")
            .replace(/\n/g, "\\n") +
          "'"
      );
    } else {
      return code;
    }
  }

  function for_js(code) {
    var split = code.replace(/^\s+|\s+$/, "").split(/\s+/);
    var key = split.shift();
    switch (key) {
      case "if":
        code = "if(" + split.join(" ") + "){";
        break;

      case "else":
        code = "}else{";
        break;

      case "elif":
      case "elseif":
        code = "}else if(" + split.join(" ") + "){";
        break;

      case "/if":
        code = "};";
        break;

      case "for":
        split[0] = split[0] || "$d";
        split[1] = split[1] || "$v";
        split[2] = split[2] || "$k";
        code = "$f(" + split.shift() + ",function(" + split.join() + "){";
        break;

      case "/for":
        code = "});";
        break;

      case "eval":
        code = code + ";";
        break;

      case "escape":
        code = echo("$e(" + split.join(" ") + ")");
        break;

      case "include":
        code = echo("$t(" + split[0] + ")(" + split[1] + ")");
        break;

      default:
        code = echo("$s(" + code + ")");
        break;
    }
    return code;
  }

  function compile$1(source) {
    var code = "'use strict';var $t=this,$e=$t.$e,$f=$t.$f,$s=$t.$s,$o='';";
    var codes = source.split(/\{|\}/);
    for (var i = 0, len = codes.length; i < len; i++) {
      i % 2 === 0 ? (code += for_html(codes[i])) : (code += for_js(codes[i]));
    }
    code += "return $o;";
    return new Function("$d", code);
  }

  var compile_1 = { compile: compile$1 };

  const { toString, forEach, escape } = utils;
  const { compile } = compile_1;

  const cache = {};

  function build(tpl) {
    const func = compile(tpl);
    return function (data) {
      try {
        return func.call(lt, data);
      } catch (e) {
        console.error(e);
        console.error("lt.js: template error", func);
        return "";
      }
    };
  }

  function lt(tpl, id) {
    tpl += "";
    let el;
    if (cache[tpl]) {
      return cache[tpl];
    } else if ((el = document.getElementById(tpl))) {
      id = id || tpl;
      tpl = el.innerHTML;
    }
    return (cache[id] = build(tpl));
  }

  lt.$e = escape;
  lt.$f = forEach;
  lt.$s = toString;

  var src = lt;

  return src;

}));
//# sourceMappingURL=lt.min.js.map
